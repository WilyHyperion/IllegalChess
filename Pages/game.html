<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Illegal Chess</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
      integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
      integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
      integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD" crossorigin="anonymous"></script>
    <img src="https://chessboardjs.com/img/chesspieces/wikipedia/wP.png" id="c2f9-9ab7-a5c4-907a-724c-1dc4-d593-195a" alt=""
        class="piece-417db" data-piece="wP" style="width: 49px; height: 49px; display: none;">

<head/>

<body>
  <!-- canvas of chess board with green and white squares -->
  <!-- create a div and center everything inside it -->
  <div style="display: flex; justify-content: center; align-items: center; flex-direction: column;">
    <div id="board1" style="width: 50%; "></div>
  </div>
  <label>Status:</label>
  <div id="status"></div>
  <label>FEN:</label>
  <div id="fen"></div>
  <label>PGN:</label>
  <div id="pgn"></div>
  

</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js"
  integrity="sha384-s3XgLpvmHyscVpijnseAmye819Ee3yaGa8NxstkJVyA6nuDFjt59u1QvuEl/mecz" crossorigin="anonymous"></script>
<script >
  const game = new Chess()
  var $status = $('#status')
  var $fen = $('#fen')
  var $pgn = $('#pgn')
  
  // --- Start Example JS --------------------------------------------------------
  var board = new Chess(),
    statusEl = $('#status'),
    fenEl = $('#fen'),
    pgnEl = $('#pgn')

  function onDragStart(source, piece, position, orientation) {
    // do not pick up pieces if the game is over
    if (game.game_over()) return false

    // only pick up pieces for the side to move
    if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
      (game.turn() === 'b'))   {
        console.log("turn: " + game.turn())
      return false
    }
  }
  let turn = 0
  function onDrop(source, target) {
    // see if the move is legal
    var move = game.move({
      from: source,
      to: target,
      promotion: 'q' 
    })

    // illegal move
    if (move === null && game.turn() === 'w') return 'snapback'
    turn+= 1;
    updateStatus()
    //get the ais move
    fetch(window.location.href + "/move", {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        move: move.to
      })
    }).then((response) => {
        return response.text()
      }).then((data) => {
        let move = game.move(data);
        if (move === null) {
          //check for a piece where it moved from
          if(data.substring('x').length > 0) {
            
            let pieceName = data.substring(0, 1)
            if(numFromLetter(pieceName) > -1) {
              pieceName = "p";
            
            }
            let loc = [ data.substring(data.length - 1), data.substring(data.length - 2, data.length - 1)] 
            loc[0] = numFromLetter(loc[0])
            loc[1] = parseInt(loc[1]) - 1
            let closestPiece = null;
            
            for(let v of game.board()){
              for(let s of v){
                if(s != null && s.type == pieceName && s.color == game.turn()){
                  if(closestPiece == null) {
                    closestPiece = s;
                  } else {
                    let closestPieceLoc = [closestPiece.loc[0], closestPiece.loc[1]]
                    let sLoc = [s.loc[0], s.loc[1]]
                    if(Math.abs(closestPieceLoc[0] - loc[0]) + Math.abs(closestPieceLoc[1] - loc[1]) > Math.abs(sLoc[0] - loc[0]) + Math.abs(sLoc[1] - loc[1])) {
                      closestPiece = s;
                    }
                  }
                }
              }
            }
            if(closestPiece != null) {
              let closestPieceLoc = [closestPiece.loc[0], closestPiece.loc[1]]
              let sLoc = [s.loc[0], s.loc[1]]
              game.put({type: closestPiece.type, color: closestPiece.color}, sLoc)
              game.remove(closestPieceLoc)
              }
          }
        }
      })
      
      
  }

  //0 based
  function numFromLetter(letter) {
    return ["a","b","c","d","e","f","g"].indexOf(letter)
  }
  function expand(arr) {
  for (let i = 0; i < arr.length; i++) {
    const row = arr[i];
    for (let j = 0; j < row.length; j++) {
      const cell = row[j];
      if (!isNaN(cell) && cell > 1) {
        const numOnes = parseInt(cell) - 1;
        for (let k = 1; k <= numOnes; k++) {
          row.splice(j + k, 0, "1");
        }
        row[j] = "1";
      }
    }
  }
  return arr;
}
function compress(arr) {
  const compressedArr = [];
  for (let i = 0; i < arr.length; i++) {
    const row = arr[i];
    const compressedRow = [];
    let numOnes = 0;
    for (let j = 0; j < row.length; j++) {
      const cell = row[j];
      if (cell === "1") {
        numOnes++;
      } else {
        if (numOnes > 0) {
          compressedRow.push(numOnes + 1);
          numOnes = 0;
        }
        compressedRow.push(cell);
      }
    }
    if (numOnes > 0) {
      compressedRow.push(numOnes + 1);
    }
    compressedArr.push(compressedRow);
  }
  return compressedArr;
}

  // update the board position after the piece snap
  // for castling, en passant, pawn promotion
  function onSnapEnd() {
    board.position(game.fen())
  }
  function pgntofen(pgn){
    fenPositions = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR'
    chessBoardArray = 
      [
      'r','n','b','q','k','b','n','r',
      'p','p','p','p','p','p','p','p',
      '1','1','1','1','1','1','1','1',
      '1','1','1','1','1','1','1','1',
      '1','1','1','1','1','1','1','1',
      '1','1','1','1','1','1','1','1',
      'P','P','P','P','P','P','P','P',
      'R','N','B','Q','K','B','N','R'
    ]
    whiteMove = true
    encroissantSquare = '-'
    castlingRights = 'KQkq'
    halfMoves = 0
    moveNumber = 0
    lastMove = 'First move'

    function printFEN() {
      return getFENpositions() + ' ' + (whiteMove ? 'w' : 'b') + ' ' + (castlingRights ? castlingRights : '-') + ' ' + encroissantSquare  + ' ' + halfMoves + ' ' + moveNumber
    }

    function getFENpositions() {
      currentFEN = ''
      rowEnds = [8, 16, 24, 32, 40, 48, 56, 64]
      rowEnds.forEach(n => {
        blankSquares = 0
        chessBoardArray.slice(n-8, n).forEach(i => {
          if (i !== '1') {
            if (blankSquares > 0) {
              currentFEN += blankSquares
              blankSquares = 0
            }
            currentFEN += i
          }
          else {
            blankSquares += 1
          }
        })
        if (blankSquares > 0) {
          currentFEN += blankSquares
          blankSquares = 0
        }
        currentFEN += '/'
      })
      currentFEN = currentFEN.slice(0,-1)
      return currentFEN
  }


  }
  function updateStatus() {
    var status = ''

    var moveColor = 'White'
    if (game.turn() === 'b') {
      moveColor = 'Black'
    }

    // checkmate?
    if (game.in_checkmate()) {
      status = 'Game over, ' + moveColor + ' is in checkmate.'
    }

    // draw?
    else if (game.in_draw()) {
      status = 'Game over, drawn position'
    }

    // game still on
    else {
      status = moveColor + ' to move'

      // check?
      if (game.in_check()) {
        status += ', ' + moveColor + ' is in check'
      }
    }

    statusEl.html(status)
    fenEl.html(game.fen())
    pgnEl.html(game.pgn())
  }

  var config = {
    draggable: true,
    position: 'start',
    onDragStart: onDragStart,
    onDrop: onDrop,
    onSnapEnd: onSnapEnd,
    moveSpeed: 'slow',
    snapbackSpeed: 500,
    snapSpeed: 125
  }
  board = Chessboard('board1', config)

  updateStatus()
  
</script>


</html>